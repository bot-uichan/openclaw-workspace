# Nostr Relayからデータ取得する方法（設計ドキュメント）

## 目的
Nostrで「Relayからどうデータを取るか」を実装前提で整理する。
この文書は**実装コードなし**で、取得方式・イベント種別・運用設計を決めるための下書き。

## 1) 取得方式の基本

Nostrクライアントは通常、複数Relayへ接続してイベントを購読する。
基本の流れ:

1. WebSocketでRelayへ接続
2. `REQ` でフィルタを送る
3. `EVENT` を受信して蓄積
4. `EOSE`（End Of Stored Events）受信で初回バックフィル完了を判断
5. 必要に応じて `CLOSE` で購読を閉じる

## 2) 取得対象イベント（最低限）

まずは以下を優先候補にする。

- kind 1: 通常投稿（ノート本文）
- kind 0: プロフィール（metadata）
- kind 3: フォロー関係（contacts）
- kind 6/16: リポスト系（採用可否は要決定）

必要なら後で追加:

- kind 7: リアクション
- kind 30023 など拡張系（クライアント依存）

## 3) REQフィルタ設計

フィルタ例（概念）:

- `authors`: 特定pubkey群
- `kinds`: 取得対象kind
- `#t`: ハッシュタグ
- `since` / `until`: 期間
- `limit`: 件数上限

設計上のポイント:

- まず期間＋limitを必ず指定して暴走取得を防ぐ
- 複数Relayの重複イベントは `event.id` で重複除去
- リアルタイム監視と過去取得（バックフィル）を分離して設計

## 4) Relay選定ポリシー（実装前）

選定観点:

- 稼働安定性（接続成功率）
- 応答速度（初回取得の速さ）
- データ偏り（Relayごとのイベント偏在）
- レート制限・接続制限

最低3系統以上のRelayを候補にして冗長化する。

## 5) データ品質管理

- 重複除去: `event.id` ベース
- 署名検証: 実装フェーズで有効化前提（設計で明記）
- 削除イベント（kind 5）反映方針を先に決める
- リポストを別カテゴリにするか本文混在するかを決める

## 6) 失敗時フォールバック

- 接続失敗Relayは一時的にサーキットブレーク
- 別Relayへ自動フェイルオーバー
- タイムアウト時は段階的再試行（指数バックオフ）
- 取得ゼロ件時は「ゼロ件」を正常系として扱う（エラー扱いしない）

## 7) 出力仕様（文書化用）

最低限ログ項目:

- relay URL
- subscription id
- filter
- received events数
- dedupe後件数
- eose受信有無
- 処理時間

これを残すと、実装後のチューニングがしやすい。

## 8) 今回の範囲（あかずさん向け）

- 今回は**文書化のみ**
- コード実装・API呼び出し・運用投入はしない
- 次段で、上記方針をそのまま実装タスクへ分解する
